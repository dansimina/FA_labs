/*
 * Simina Dan-Marius
 * Grupa 2
 *
 * Pentru build tree iau un vectorul cu elementele ordonate si capetele lui(left si right) cu care vreau sa creez arborele perfect echilibrat.
 * Apoi creez mereu nodul curent in care tin elementul din mijloc, size-ul este egal cu numarul de elemente din bucata de vector pe
 * care o prelucrez la acel moment, iar pentru copii lui apelez recursiv pentru bucata de vector de dinaintea mijlocului(left, mijloc - 1)
 * si pentru bucata de vector de dupa elementul din mijloc (mijloc + 1, right).
 * Complexitate O(n).
 *
 * Pentru os select plec de la radacina si caut elementul cu rank-ul i, pentru asta compar i cu rank-ul nodului curent, iar
 * daca rank-ul lui e egal cu i inseamna ca l-am gasit, daca i este mai mic ca rank-ul nodului curent atunci o sa caut i in continuare
 * in subarborele din partea stanga, iar daca i este mai mare decat rank-ul nodului curent o sa caut nodul cu rank-ul i - rank-ul nodului
 * curent din partea dreapta.
 * Complexitate O(log n).
 *
 * Pentru os delete fac mai intai stergerea clasica pentru un element din arborele binar de cautare, iar mai apoi merg din punctul din care
 * se sterge nodul in sus pe arbore si refac size-ul fiecarui nod;
 * Complexitate O(log n).
 *
 * OS select seamana cu randomized selection.
 *
 * Pentru arbori rosu si negru fac inserarea normal ca intr-un arbore binar de cautare, iar apoi apelez functia insert fixup care verifica
 * ca arborele sa respecte proprietatiile pentru arbori rosu si negru.
 * Complexiatete O(log n).
 */

#include <iostream>
#include "Profiler.h"

using namespace std;

#define maxSize 10000
#define stepSize 100
#define nrTests 5

Profiler profiler("arbori");

///Arbore binar de cautare echilibrat:

struct Node {
    int key;
    int size;
    Node *left, *right, *parent;
};

Node *create(int key, int size) {
    Node *p = new Node;
    p->key = key;
    p->size = size;
    p->left = NULL;
    p->right = NULL;
    p->parent = NULL;

    return p;
}

Node *buildTree(int A[], int left, int right, Node *parent) {
    if (left > right)
        return NULL;

    int m = (left + right) / 2;

    Node *node = create(A[m], right - left + 1);
    node->parent = parent;
    node->left = buildTree(A, left, m - 1, node);
    node->right = buildTree(A, m + 1, right, node);

    return node;
}

Node *osSelect(Node *root, int i, int n) {
    Operation opTotale = profiler.createOperation("Operatii select", n);

    int rank = 1;
    opTotale.count();
    if (root->left != NULL)
        rank = (root->left)->size + 1;

    opTotale.count();
    if (i == rank) {
        return root;
    } else {
        opTotale.count();
        if (i < rank)
            return osSelect(root->left, i, n);

        return osSelect(root->right, i - rank, n);
    }
}

Node *treeSuccessor(Node *node, int n) {
    Operation opTotale = profiler.createOperation("Operatii delete", n);

    opTotale.count();
    if (node->right != NULL) {
        opTotale.count();
        node = node->right;

        opTotale.count();
        while (node->left != NULL) {
            opTotale.count(2);
            node = node->left;
        }
        return node;
    }

    opTotale.count();
    Node *parent = node->parent;

    opTotale.count(2);
    while (parent != NULL and node == parent->right) {
        opTotale.count(4);
        node = parent;
        parent = parent->parent;
    }
    return parent;
}

Node *osDelete(Node *root, Node *nodeZ, int n) {
    Operation opTotale = profiler.createOperation("Operatii delete", n);

    Node *nodeY = NULL, *nodeX = NULL;

    opTotale.count(3);
    if (nodeZ->left == NULL or nodeZ->right == NULL) {
        nodeY = nodeZ;
    } else {
        nodeY = treeSuccessor(nodeZ, n);
    }

    opTotale.count(2);
    if (nodeY->left != NULL) {
        nodeX = nodeY->left;
    } else {
        nodeX = nodeY->right;
    }

    opTotale.count();
    if (nodeX != NULL) {
        opTotale.count();
        nodeX->parent = nodeY->parent;
    }

    opTotale.count();
    if (nodeY->parent == NULL) {
        root = nodeX;
    } else {
        opTotale.count(2);
        if (nodeY == (nodeY->parent)->left) {
            (nodeY->parent)->left = nodeX;
        } else {
            (nodeY->parent)->right = nodeX;
        }
    }

    opTotale.count();
    if (nodeY != nodeZ) {
        opTotale.count();
        nodeZ->key = nodeY->key;
        //nodeZ->size = nodeY->size;
    }

    for (Node *p = nodeY; p != NULL; p = p->parent) {
        opTotale.count(3);
        p->size = (p->left == NULL ? 0 : (p->left)->size) + (p->right == NULL ? 0 : (p->right)->size) + 1;
    }

    delete nodeY;

    return root;
}

int *generareVector(int n) {
    int *a = new int[n];
    for (int i = 0; i < n; i++)
        a[i] = i + 1;

    return a;
}

void prettyPrint(Node *root, int level) {
    if (root == NULL)
        return;

    for (int i = 0; i < level; i++)
        cout << "  ";
    cout << root->key << " size: " << root->size << "\n";

    prettyPrint(root->left, level + 1);
    prettyPrint(root->right, level + 1);
}

void demo() {
    int n = 11;
    int *a = generareVector(n);

    Node *root = buildTree(a, 0, n - 1, NULL);
    delete[] a;

    prettyPrint(root, 0);

    Node *p;

    p = osSelect(root, 11, n);
    cout << p->key << "\n";
    root = osDelete(root, p, n);
    prettyPrint(root, 0);

    p = osSelect(root, 5, n);
    cout << p->key << "\n";
    root = osDelete(root, p, n);
    prettyPrint(root, 0);

    p = osSelect(root, 6, n);
    cout << p->key << "\n";
    root = osDelete(root, p, n);
    prettyPrint(root, 0);
}

void perf() {
    for (int n = stepSize; n <= maxSize; n += stepSize) {
        for (int test = 0; test < nrTests; test++) {
            int *a = generareVector(n);
            Node *root = buildTree(a, 0, n - 1, NULL);
            delete[] a;

            for (int i = 0; i < n; i++) {
                int p = rand() % (root->size) + 1;

                Node *node = osSelect(root, p, n);
                root = osDelete(root, node, n);

            }
        }
    }

    profiler.divideValues("Operatii select", nrTests);
    profiler.divideValues("Operatii delete", nrTests);
    profiler.createGroup("Operatii", "Operatii select", "Operatii delete");
    profiler.showReport();
}

///Arbori rosu-negru:

enum colorRedBlack {
    black, red
};

struct NodeRB {
    int key;
    int size;
    NodeRB *left, *right, *parent;
    colorRedBlack color;
};

NodeRB *createRB(int key, int size) {
    NodeRB *p = new NodeRB;
    p->key = key;
    p->size = size;
    p->left = NULL;
    p->right = NULL;
    p->parent = NULL;
    p->color = black;

    return p;
}

struct redBlackTree {
    NodeRB *root;
    NodeRB *nil = createRB(-1, 0);
};

void leftRotate(redBlackTree &T, NodeRB *nodeX) {
    NodeRB *nodeY = nodeX->right;
    nodeX->right = nodeY->left;

    if (nodeY->left != T.nil) {
        nodeY->left->parent = nodeX;
    }

    nodeY->parent = nodeX->parent;

    if (nodeX->parent == T.nil) {
        T.root = nodeY;
    } else if (nodeX == nodeX->parent->left) {
        nodeX->parent->left = nodeY;
    } else {
        nodeX->parent->right = nodeY;
    }

    nodeY->left = nodeX;
    nodeX->parent = nodeY;

    nodeX->size = nodeX->left->size + nodeX->right->size + 1;
    nodeY->size = nodeY->left->size + nodeY->right->size + 1;
}

void rightRotate(redBlackTree &T, NodeRB *nodeX) {
    NodeRB *nodeY = nodeX->left;
    nodeX->left = nodeY->right;

    if (nodeY->right != T.nil) {
        nodeY->right->parent = nodeX;
    }

    nodeY->parent = nodeX->parent;

    if (nodeX->parent == T.nil) {
        T.root = nodeY;
    } else if (nodeX == nodeX->parent->right) {
        nodeX->parent->right = nodeY;
    } else {
        nodeX->parent->left = nodeY;
    }

    nodeY->right = nodeX;
    nodeX->parent = nodeY;

    nodeX->size = nodeX->left->size + nodeX->right->size + 1;
    nodeY->size = nodeY->left->size + nodeY->right->size + 1;
}

void rbInsertFixup(redBlackTree &T, NodeRB *nodeZ) {
    while (nodeZ->parent->color == red) {
        if (nodeZ->parent == nodeZ->parent->parent->left) {
            NodeRB *nodeY = nodeZ->parent->parent->right;
            if (nodeY->color == red) {
                nodeZ->parent->color = black;
                nodeY->color = black;
                nodeZ->parent->parent->color = red;
                nodeZ = nodeZ->parent->parent;
            } else {
                if (nodeZ == nodeZ->parent->right) {
                    nodeZ = nodeZ->parent;
                    leftRotate(T, nodeZ);
                }

                nodeZ->parent->color = black;
                nodeZ->parent->parent->color = red;
                rightRotate(T, nodeZ->parent->parent);
            }
        } else {
            NodeRB *nodeY = nodeZ->parent->parent->left;
            if (nodeY->color == red) {
                nodeZ->parent->color = black;
                nodeY->color = black;
                nodeZ->parent->parent->color = red;
                nodeZ = nodeZ->parent->parent;
            } else {
                if (nodeZ == nodeZ->parent->left) {
                    nodeZ = nodeZ->parent;
                    rightRotate(T, nodeZ);
                }
                nodeZ->parent->color = black;
                nodeZ->parent->parent->color = red;
                leftRotate(T, nodeZ->parent->parent);
            }
        }
    }

    T.root->color = black;
}

void rbInsert(redBlackTree &T, NodeRB *nodeZ) {
    NodeRB *nodeX = T.root;
    NodeRB *nodeY = T.nil;

    while (nodeX != T.nil) {
        nodeY = nodeX;
        nodeX->size++;
        if (nodeZ->key < nodeX->key) {
            nodeX = nodeX->left;
        } else {
            nodeX = nodeX->right;
        }
    }

    nodeZ->parent = nodeY;

    if (nodeY == T.nil) {
        T.root = nodeZ;
    } else if (nodeZ->key < nodeY->key) {
        nodeY->left = nodeZ;
    } else {
        nodeY->right = nodeZ;
    }

    nodeZ->left = T.nil;
    nodeZ->right = T.nil;
    nodeZ->color = red;

    rbInsertFixup(T, nodeZ);
}

NodeRB *treeSuccessorRB(redBlackTree T, NodeRB *node) {
    if (node->right != T.nil) {
        node = node->right;

        while (node->left != T.nil) {
            node = node->left;
        }
        return node;
    }

    NodeRB *parent = node->parent;

    while (parent != T.nil and node == parent->right) {
        node = parent;
        parent = parent->parent;
    }
    return parent;
}

void rbDelete(redBlackTree &T, NodeRB *nodeZ) {
    NodeRB *nodeY = T.nil, *nodeX = T.nil;

    if (nodeZ->left == T.nil or nodeZ->right == T.nil) {
        nodeY = nodeZ;
    } else {
        nodeY = treeSuccessorRB(T, nodeZ);
    }

    if (nodeY->left != T.nil) {
        nodeX = nodeY->left;
    } else {
        nodeX = nodeY->right;
    }

    if (nodeX != T.nil) {
        nodeX->parent = nodeY->parent;
    }

    if (nodeY->parent == T.nil) {
        T.root = nodeX;
    } else {
        if (nodeY == (nodeY->parent)->left) {
            (nodeY->parent)->left = nodeX;
        } else {
            (nodeY->parent)->right = nodeX;
        }
    }

    if (nodeY != nodeZ) {
        nodeZ->key = nodeY->key;
        nodeZ->size = nodeY->size;
    }

    for (NodeRB *p = nodeY; p != T.nil; p = p->parent) {
        p->size = (p->left == T.nil ? 0 : (p->left)->size) + (p->right == T.nil ? 0 : (p->right)->size) + 1;
    }

    delete nodeY;
}

NodeRB *osSelectRB(redBlackTree T, NodeRB *root, int i) {
    int rank = 1;
    if (root->left != T.nil)
        rank = (root->left)->size + 1;

    if (i == rank) {
        return root;
    } else {
        if (i < rank)
            return osSelectRB(T, root->left, i);

        return osSelectRB(T, root->right, i - rank);
    }
}

void inorder(NodeRB *root) {
    if (root == NULL)
        return;

    inorder(root->left);
    if (root->key >= 0)cout << root->key << " ";
    inorder(root->right);
}

void prettyPrintRB(NodeRB *root, int level) {
    if (root->key == -1)
        return;

    for (int i = 0; i < level; i++)
        cout << "  ";
    cout << root->key << " size: " << root->size << "\n";

    prettyPrintRB(root->left, level + 1);
    prettyPrintRB(root->right, level + 1);
}

void demoRB() {
    redBlackTree T;
    T.root = T.nil;
    int n = 11;

    for (int i = 1; i <= n; i++)
        rbInsert(T, createRB(i, 1));
    prettyPrintRB(T.root, 0);

    for(int i = 1; i <= n; i++) {
        int p = rand() % (T.root->size) + 1;
        NodeRB *node = osSelectRB(T, T.root, p);
        rbDelete(T, node);
    }

}

int main() {

//    demo();
//    perf();
//    demoRB();
    return 0;
}
